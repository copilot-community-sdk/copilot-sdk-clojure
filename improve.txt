 8. Simplify dispatch-event! with doseq and error handling

     ;; Current:
     (doseq [ch subscribers]
       (let [success (put! ch event)]
         (when-not success
           (log/debug "Failed to put..."))))

     ;; Simpler (put! returns boolean, but nil subscribers would error):
     (doseq [ch subscribers]
       (put! ch event))  ; If channel closed, put! returns false - that's fine

   9. Use some-> for cleaner nil handling

     ;; Current:
     (when-let [session (get-in @(:state client) [:sessions session-id])]
       (session/dispatch-event! session event))

     ;; Cleaner:
     (some-> @(:state client)
             (get-in [:sessions session-id])
             (session/dispatch-event! event))

   10. Consider using pipeline-async for notification routing

   The notification router is essentially a pipeline:

     ;; Current manual go-loop:
     (go-loop []
       (let [notif (<! notif-ch)]
         (when notif
           (when (= (:method notif) "session.event")
             ...)
           (recur))))

     ;; Could use pipeline with transducer:
     (async/pipeline 1 processed-ch
                     (filter #(= (:method %) "session.event"))
                     notif-ch)

   ---------------------------------------------------------------------------------------------------------------------------------------------------------------

   ðŸ”µ Style & Idiom Suggestions

   11. Use kebab-case consistently

   Wire format uses camelCase (required for JSON-RPC), but internal code mixes:

     :sessionId  ; wire format - fine
     :session-id ; Clojure style - use this internally

   Consider using camel-snake-kebab library or explicit conversion at boundaries.

   12. Leverage cond-> more

   Already well-used, but some places could benefit:

     ;; In normalize-tool-result:
     (cond
       (nil? result) {...}
       (and (map? result) (:textResultForLlm result)) result
       (string? result) {...}
       :else {...})

     ;; Fine as-is, but consider a multimethod if this grows

   13. Add specs to public API functions

   The specs are defined but not enforced:

     (defn create-session [client config]
       ;; Add: (s/assert ::session-config config)
       ...)

   Or use s/fdef with instrumentation for development.

   14. The logging macros are good, but consider clojure.tools.logging

   The custom logging is fine for a library, but clojure.tools.logging integrates better with existing infrastructure (SLF4J, Logback, etc.).
